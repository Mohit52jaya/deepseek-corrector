

<!doctype html>Â Â 

<html>Â Â 

<head>Â Â 

<meta charset="utf-8"/>Â Â 

<meta name="viewport" content="width=device-width,initial-scale=1"/>Â Â 

<title>DeepSeek Corrector V8 â€” Clean Format Output</title>Â Â 

<style>Â Â 

Â Â body{font-family:Arial,system-ui;max-width:960px;margin:10px auto;padding:12px}Â Â 

Â Â #log{white-space:pre-wrap;background:#0b1220;color:#e6ffd9;padding:10px;border-radius:6px;height:65vh;overflow:auto;font-size:13px}Â Â 

Â Â button{padding:8px 12px;margin-right:6px;border-radius:5px;border:1px solid #999}Â Â 

</style>Â Â 

</head>Â Â 

Â Â 

<body>Â Â 

<h2>DeepSeek Corrector V8 â€” Format Preserving Cleaner</h2>Â Â 

Â Â 

<label>Choose TXT File:Â Â Â Â 

Â Â <input id="fileInput" type="file" accept=".txt"/>Â Â 

</label>Â Â 

Â Â 

<label>Chunk Size:Â Â Â Â 

Â Â <input id="chunkSize" type="number" value="2000"/>Â Â 

</label>Â Â 

Â Â 

<label>Delay (ms):Â Â Â Â 

Â Â <input id="delay" type="number" value="1200"/>Â Â 

</label>Â Â 

Â Â 

<button id="startBtn">Start</button>Â Â 

<button id="stopBtn" disabled>Stop</button>Â Â 

Â Â 

<h3>Processing Log:</h3>Â Â 

<div id="log">Log will appear...</div>Â Â 

Â Â 

<a id="downloadLink"></a>Â Â 

Â Â 

<script src="https://js.puter.com/v2/"></script>Â Â 

Â Â 

<script>Â Â 

(function(){Â Â 

Â Â 

const fileInput = document.getElementById("fileInput");Â Â 

const chunkSizeInput = document.getElementById("chunkSize");Â Â 

const delayInput = document.getElementById("delay");Â Â 

const startBtn = document.getElementById("startBtn");Â Â 

const stopBtn = document.getElementById("stopBtn");Â Â 

const logBox = document.getElementById("log");Â Â 

const downloadLink = document.getElementById("downloadLink");Â Â 

Â Â 

let stopFlag = false;Â Â 

let correctedChunks = [];Â Â 

Â Â 

function log(t){Â Â 

Â Â logBox.textContent += t + "\n\n";Â Â 

Â Â logBox.scrollTop = logBox.scrollHeight;Â Â 

}Â Â 

Â Â 

function clean(t){Â Â 

Â Â return t.replace(/[^\S\r\n]{2,}/g," ").replace(/\u0000/g,"").trim();Â Â 

}Â Â 

Â Â 

function splitChunks(text, max){Â Â 

Â Â let out = [];Â Â 

Â Â let pos = 0;Â Â 

Â Â while(pos < text.length){Â Â 

Â Â Â Â let end = pos + max;Â Â 

Â Â 

Â Â Â Â if(end >= text.length){Â Â 

Â Â Â Â Â Â out.push(text.slice(pos));Â Â 

Â Â Â Â Â Â break;Â Â 

Â Â Â Â }Â Â 

Â Â 

Â Â Â Â // try break on newline for clean splitÂ Â 

Â Â Â Â let cut = text.lastIndexOf("\n", end);Â Â 

Â Â Â Â if(cut <= pos) cut = end;Â Â 

Â Â 

Â Â Â Â out.push(text.slice(pos, cut));Â Â 

Â Â Â Â pos = cut;Â Â 

Â Â }Â Â 

Â Â return out;Â Â 

}Â Â 

Â Â 

async function sendToAI(content){Â Â 

Â Â let prompt = `Â Â 

You are an expert text corrector.Â Â 

Â Â 

RULES:
1. Fix the OCR errors in this Hindi text (e.g., change 'à¤à¥‹fà¤¤à¤¹à¤¾à¤¸à¤¿à¤•' to 'à¤à¤¤à¤¿à¤¹à¤¾à¤¸à¤¿à¤•').
2. Maintain the one-liner format: [Question/Fact] â€” [Answer] [Exam dates]. but don't write Question - answer (exam dates heading just give content in this format 
3. Exam dates, years, and shifts must remain on the SAME line.
4. correct "garbage" characters and non-Hindi symbols like 'Exà¥‚raà¤®à¥à¥‚à¤¾d' or 'Yà¤£à¥à¤Š'. on possibility 
5. Do NOT add or remove historical facts.
6. Remove footers like page numbers or names (e.g., 'ashutosh shukla').
7. Keep English technical terms like 'Shift', 'Stage', or 'NTPC' as they are.
8. New question should start from next line and bullet dot at starting 
9. mention heading and sub headings of subject 
10. if question is incomplete then complete that question 

Chunk start:Â Â 

${content}Â Â 

Chunk end.Â Â 

`;Â Â 

Â Â 

Â Â try {Â Â 

Â Â Â Â let r = await puter.ai.chat(prompt, {model:"deepseek/deepseek-v3.2",max_tokens:2000});Â Â 

Â Â Â Â if(!r || !r.message || !r.message.content){Â Â 

Â Â Â Â Â Â throw new Error("NO_RESPONSE");Â Â 

Â Â Â Â }Â Â 

Â Â Â Â return String(r.message.content);Â Â 

Â Â }Â Â Â 

Â Â catch(e){Â Â 

Â Â Â Â return "AI_ERROR";Â Â 

Â Â }Â Â 

}Â Â 

Â Â 

startBtn.onclick = async ()=>{Â Â 

Â Â const file = fileInput.files[0];Â Â 

Â Â if(!file){ alert("Choose TXT file"); return; }Â Â 

Â Â 

Â Â startBtn.disabled = true;Â Â 

Â Â stopBtn.disabled = false;Â Â 

Â Â stopFlag = false;Â Â 

Â Â correctedChunks = [];Â Â 

Â Â logBox.textContent = "";Â Â 

Â Â 

Â Â let raw = await file.text();Â Â 

Â Â raw = clean(raw);Â Â 

Â Â 

Â Â let chunkSize = parseInt(chunkSizeInput.value) || 2000;Â Â 

Â Â let delay = parseInt(delayInput.value) || 1200;Â Â 

Â Â 

Â Â let chunks = splitChunks(raw, chunkSize);Â Â 

Â Â 

Â Â log("Total chunks: "+chunks.length);Â Â 

Â Â 

Â Â for(let i=0;i<chunks.length;i++){Â Â 

Â Â Â Â if(stopFlag){ log("Stopped!"); break; }Â Â 

Â Â 

Â Â Â Â let ch = chunks[i];Â Â 

Â Â Â Â log(`========== Processing chunk ${i+1} / ${chunks.length} ==========\n\n${ch}`);Â Â 

Â Â 

Â Â Â Â let output = "";Â Â 

Â Â Â Â let success = false;Â Â 

Â Â 

Â Â Â Â for(let a=1;a<=3;a++){Â Â 

Â Â Â Â Â Â log(`Attempt ${a} for chunk ${i+1}`);Â Â 

Â Â Â Â Â Â output = await sendToAI(ch);Â Â 

Â Â 

Â Â Â Â Â Â if(output !== "AI_ERROR" && output.trim() !== ""){Â Â 

Â Â Â Â Â Â Â Â success = true;Â Â 

Â Â Â Â Â Â Â Â break;Â Â 

Â Â Â Â Â Â }Â Â 

Â Â 

Â Â Â Â Â Â log("AI ERROR, retrying...");Â Â 

Â Â Â Â Â Â await new Promise(r=>setTimeout(r,1000));Â Â 

Â Â Â Â }Â Â 

Â Â 

Â Â Â Â if(!success){Â Â 

Â Â Â Â Â Â output = `[FAILED chunk ${i+1} after 3 attempts]`;Â Â 

Â Â Â Â }Â Â 

Â Â 

Â Â Â Â log("----- CORRECTED OUTPUT -----\n"+output);Â Â 

Â Â 

Â Â Â Â correctedChunks.push(output);Â Â 

Â Â 

Â Â Â Â await new Promise(r=>setTimeout(r, delay));Â Â 

Â Â }Â Â 

Â Â 

Â Â log("Merging all chunks...");Â Â 

Â Â 

Â Â let finalText = correctedChunks.join("\n\n");Â Â 

Â Â 

Â Â const blob = new Blob([finalText],{type:"text/plain"});Â Â 

Â Â const url = URL.createObjectURL(blob);Â Â 

Â Â downloadLink.href = url;Â Â 

Â Â downloadLink.download = file.name.replace(".txt","")+"_corrected.txt";Â Â 

Â Â downloadLink.textContent = "Download Corrected File";Â Â 

Â Â 

Â Â log("ðŸŽ‰ Processing complete!");Â Â 

Â Â startBtn.disabled = false;Â Â 

Â Â stopBtn.disabled = true;Â Â 

};Â Â 

Â Â 

stopBtn.onclick = ()=>{Â Â 

Â Â stopFlag = true;Â Â 

Â Â stopBtn.disabled = true;Â Â 

Â Â log("STOP Requested.");Â Â 

};Â Â 

Â Â 

})();Â Â 

</script>Â Â 

Â Â 

</body>Â Â 

</html>
Â Â <input id="fileInput" type="file" accept=".txt"/>Â Â 

</label>Â Â 

Â Â 

<label>Chunk Size:Â Â Â Â 

Â Â <input id="chunkSize" type="number" value="2000"/>Â Â 

</label>Â Â 

Â Â 

<label>Delay (ms):Â Â Â Â 

Â Â <input id="delay" type="number" value="1200"/>Â Â 

</label>Â Â 

Â Â 

<button id="startBtn">Start</button>Â Â 

<button id="stopBtn" disabled>Stop</button>Â Â 

Â Â 

<h3>Processing Log:</h3>Â Â 

<div id="log">Log will appear...</div>Â Â 

Â Â 

<a id="downloadLink"></a>Â Â 

Â Â 

<script src="https://js.puter.com/v2/"></script>Â Â 

Â Â 

<script>Â Â 

(function(){Â Â 

Â Â 

const fileInput = document.getElementById("fileInput");Â Â 

const chunkSizeInput = document.getElementById("chunkSize");Â Â 

const delayInput = document.getElementById("delay");Â Â 

const startBtn = document.getElementById("startBtn");Â Â 

const stopBtn = document.getElementById("stopBtn");Â Â 

const logBox = document.getElementById("log");Â Â 

const downloadLink = document.getElementById("downloadLink");Â Â 

Â Â 

let stopFlag = false;Â Â 

let correctedChunks = [];Â Â 

Â Â 

function log(t){Â Â 

Â Â logBox.textContent += t + "\n\n";Â Â 

Â Â logBox.scrollTop = logBox.scrollHeight;Â Â 

}Â Â 

Â Â 

function clean(t){Â Â 

Â Â return t.replace(/[^\S\r\n]{2,}/g," ").replace(/\u0000/g,"").trim();Â Â 

}Â Â 

Â Â 

function splitChunks(text, max){Â Â 

Â Â let out = [];Â Â 

Â Â let pos = 0;Â Â 

Â Â while(pos < text.length){Â Â 

Â Â Â Â let end = pos + max;Â Â 

Â Â 

Â Â Â Â if(end >= text.length){Â Â 

Â Â Â Â Â Â out.push(text.slice(pos));Â Â 

Â Â Â Â Â Â break;Â Â 

Â Â Â Â }Â Â 

Â Â 

Â Â Â Â // try break on newline for clean splitÂ Â 

Â Â Â Â let cut = text.lastIndexOf("\n", end);Â Â 

Â Â Â Â if(cut <= pos) cut = end;Â Â 

Â Â 

Â Â Â Â out.push(text.slice(pos, cut));Â Â 

Â Â Â Â pos = cut;Â Â 

Â Â }Â Â 

Â Â return out;Â Â 

}Â Â 

Â Â 

async function sendToAI(content){Â Â 

Â Â let prompt = `Â Â 

You are an expert text corrector.Â Â 

Â Â 

RULES:
1. Fix the OCR errors in this Hindi text (e.g., change 'à¤à¥‹fà¤¤à¤¹à¤¾à¤¸à¤¿à¤•' to 'à¤à¤¤à¤¿à¤¹à¤¾à¤¸à¤¿à¤•').
2. Maintain the one-liner format: [Question/Fact] â€” [Answer] [Exam Info].
3. Exam dates, years, and shifts must remain on the SAME line.
4. Remove "garbage" characters and non-Hindi symbols like 'Exà¥‚raà¤®à¥à¥‚à¤¾d' or 'Yà¤£à¥à¤Š'.
5. Do NOT add or remove historical facts.
6. Remove footers like page numbers or names (e.g., 'ashutosh shukla').
7. Keep English technical terms like 'Shift', 'Stage', or 'NTPC' as they are.

Chunk start:Â Â 

${content}Â Â 

Chunk end.Â Â 

`;Â Â 

Â Â 

Â Â try {Â Â 

Â Â Â Â let r = await puter.ai.chat(prompt, {model:"deepseek/deepseek-v3.2",max_tokens:2000});Â Â 

Â Â Â Â if(!r || !r.message || !r.message.content){Â Â 

Â Â Â Â Â Â throw new Error("NO_RESPONSE");Â Â 

Â Â Â Â }Â Â 

Â Â Â Â return String(r.message.content);Â Â 

Â Â }Â Â Â 

Â Â catch(e){Â Â 

Â Â Â Â return "AI_ERROR";Â Â 

Â Â }Â Â 

}Â Â 

Â Â 

startBtn.onclick = async ()=>{Â Â 

Â Â const file = fileInput.files[0];Â Â 

Â Â if(!file){ alert("Choose TXT file"); return; }Â Â 

Â Â 

Â Â startBtn.disabled = true;Â Â 

Â Â stopBtn.disabled = false;Â Â 

Â Â stopFlag = false;Â Â 

Â Â correctedChunks = [];Â Â 

Â Â logBox.textContent = "";Â Â 

Â Â 

Â Â let raw = await file.text();Â Â 

Â Â raw = clean(raw);Â Â 

Â Â 

Â Â let chunkSize = parseInt(chunkSizeInput.value) || 2000;Â Â 

Â Â let delay = parseInt(delayInput.value) || 1200;Â Â 

Â Â 

Â Â let chunks = splitChunks(raw, chunkSize);Â Â 

Â Â 

Â Â log("Total chunks: "+chunks.length);Â Â 

Â Â 

Â Â for(let i=0;i<chunks.length;i++){Â Â 

Â Â Â Â if(stopFlag){ log("Stopped!"); break; }Â Â 

Â Â 

Â Â Â Â let ch = chunks[i];Â Â 

Â Â Â Â log(`========== Processing chunk ${i+1} / ${chunks.length} ==========\n\n${ch}`);Â Â 

Â Â 

Â Â Â Â let output = "";Â Â 

Â Â Â Â let success = false;Â Â 

Â Â 

Â Â Â Â for(let a=1;a<=3;a++){Â Â 

Â Â Â Â Â Â log(`Attempt ${a} for chunk ${i+1}`);Â Â 

Â Â Â Â Â Â output = await sendToAI(ch);Â Â 

Â Â 

Â Â Â Â Â Â if(output !== "AI_ERROR" && output.trim() !== ""){Â Â 

Â Â Â Â Â Â Â Â success = true;Â Â 

Â Â Â Â Â Â Â Â break;Â Â 

Â Â Â Â Â Â }Â Â 

Â Â 

Â Â Â Â Â Â log("AI ERROR, retrying...");Â Â 

Â Â Â Â Â Â await new Promise(r=>setTimeout(r,1000));Â Â 

Â Â Â Â }Â Â 

Â Â 

Â Â Â Â if(!success){Â Â 

Â Â Â Â Â Â output = `[FAILED chunk ${i+1} after 3 attempts]`;Â Â 

Â Â Â Â }Â Â 

Â Â 

Â Â Â Â log("----- CORRECTED OUTPUT -----\n"+output);Â Â 

Â Â 

Â Â Â Â correctedChunks.push(output);Â Â 

Â Â 

Â Â Â Â await new Promise(r=>setTimeout(r, delay));Â Â 

Â Â }Â Â 

Â Â 

Â Â log("Merging all chunks...");Â Â 

Â Â 

Â Â let finalText = correctedChunks.join("\n\n");Â Â 

Â Â 

Â Â const blob = new Blob([finalText],{type:"text/plain"});Â Â 

Â Â const url = URL.createObjectURL(blob);Â Â 

Â Â downloadLink.href = url;Â Â 

Â Â downloadLink.download = file.name.replace(".txt","")+"_corrected.txt";Â Â 

Â Â downloadLink.textContent = "Download Corrected File";Â Â 

Â Â 

Â Â log("ðŸŽ‰ Processing complete!");Â Â 

Â Â startBtn.disabled = false;Â Â 

Â Â stopBtn.disabled = true;Â Â 

};Â Â 

Â Â 

stopBtn.onclick = ()=>{Â Â 

Â Â stopFlag = true;Â Â 

Â Â stopBtn.disabled = true;Â Â 

Â Â log("STOP Requested.");Â Â 

};Â Â 

Â Â 

})();Â Â 

</script>Â Â 

Â Â 

</body>Â Â 

</html>

